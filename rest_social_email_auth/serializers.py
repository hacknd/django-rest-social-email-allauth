# Python Packages
import logging

# DRF Packages
from rest_framework import serializers
from rest_framework.validators import UniqueValidator

# Installed Packages
from rest_social_auth.serializers import UserKnoxSerializer

# Django Packages
from django.contrib.auth import get_user_model, password_validation
from django.utils.translation import gettext_lazy as __

# Local Packages
from rest_social_email_auth import signals, models, app_settings

# Local Variables
logger = logging.getLogger(__name__)


class CreateUserSerializer(serializers.ModelSerializer):
    email = serializers.EmailField(
        required=True,
        validators=[UniqueValidator(queryset=get_user_model().objects.all())],
    )
    username = serializers.CharField(
        required=True,
        max_length=13,
        validators=[UniqueValidator(queryset=get_user_model().objects.all())],
    )
    password = serializers.CharField(min_length=8, write_only=True)

    def create(self, validated_data):
        account = get_user_model().objects.create_user(
            username=validated_data["username"],
            email=validated_data["email"],
            password=validated_data["password"],
        )

        signals.user_registered.send(sender=self.__class__, user=account)
        return account

    def validate_email(self, email):
        """
		Validate the provided email address.

		Args:
			email:
				The email address to validate.

		Returns:
			The provided email address, transformed to match the RFC
			spec. Namely, the domain portion of the email must be 
			lowercase.
			# Sowy for the formality onnichan or ani-wee its for the best.
		"""
        user, domain = email.rsplit("@", 1)
        email = "@".join([user, domain.lower()])

        if self.instance and email and self.instance.email != email:
            raise serializers.ValidationError(
                __("Existing emails may not be edited. Create a new one " "instead.")
            )

        return email

    def validate_password(self, password):
        """
		Validate the provided password.


		Args:
			password (str):
				The password provided by the user.

		Returns:
			str:
				The validated password.

		Raises:
			ValidationError:
				If the provided password does not pass the
				considered password validators.
		"""

        password_validation.validate_password(password)

        return password

    class Meta(object):
        model = get_user_model()
        fields = ("id", "username", "email", "password")


class EmailSerializer(serializers.ModelSerializer):
    """
	Serializer for email addresses
	"""

    class Meta(object):
        extra_kwargs = {
            "email": {
                # We remove the autogenerated 'unique' validator to
                # avoid leaking email addresses
                "validators": []
            }
        }
        fields = ("id", "created_at", "email", "is_primary", "is_verified")
        model = models.EmailAddress
        read_only_fields = ("is_verified",)

    def create(self, validated_data):
        """
		Create a new email and send a confirmation to it.

		Returns:
			The newly creating ``EmailAddress`` instance.
		"""
        email_query = models.EmailAddress.objects.filter(
            email=self.validated_data["email"]
        )

        if email_query.exists():
            email = email_query.get()

            email.send_duplicate_notification()
        else:
            email = super(EmailSerializer, self).create(validated_data)
            email.send_confirmation()

            user = validated_data.get("user")
            query = models.EmailAddress.objects.filter(is_primary=True, user=user)

            if not query.exists():
                email.set_primary()

        return email

    def update(self, instance, validated_data):
        """
		Update the instance the serializer is bound to.


		Args:
			instance:
				The instance the serializer is bound to.
			validated_data:
				The data to update the serializer with.

		Returns:
			The updated instance.
		"""
        is_primary = validated_data.pop("is_primary", False)

        instance = super(EmailSerializer, self).update(instance, validated_data)

        if is_primary:
            instance.set_primary()

        return instance

    def validate_email(self, email):
        """
		Validate the provided email address.

		The email address is first modified to match the RFC spec.
		Namely, the domain portion of the email is lowercased.

		Returns:
			The validated email address.

		Raises:
			serializers.ValidationError:
				If the serializer is bound and the provided email
				doesn't match the existong email address.
		"""
        user, domain = email.rsplit("@", 1)
        email = "@".join([user, domain.lower()])

        if self.instance and email and self.instance.email != email:
            raise serializers.ValidationError(
                __("Existing emails may not be edited. Create a new one " "instead.")
            )

        return email

    def validate_is_primary(self, is_primary):
        """
		Validate the provided 'is_primary' parameter.

		Returns:
			The validated 'is_primary' value.

		Raises:
			serializers.ValidationError:
				If the user attempted to mark an unverified email as their primary email address.        
		"""

        # TODO: Setting is_primary to 'False' should probably not be allowed.
        if is_primary and not (self.instance and self.instance.is_verified):
            raise serializers.ValidationError(
                __(
                    "Unverified email addresses may not be used as the "
                    "primary address."
                )
            )
        return is_primary


class EmailVerificationSerializer(serializers.Serializer):
    """
	Serializer for verifying an email address
	"""

    email = serializers.EmailField(read_only=True)
    key = serializers.CharField(write_only=True)
    password = serializers.CharField(style={"input_type": "password"}, write_only=True)

    def __init__(self, *args, **kwargs):
        """
		Conditionally remove the password field based on if a password is required to verify an email address

		"""
        super().__init__(*args, **kwargs)

        self._confirmation = None

        if not app_settings.EMAIL_VERIFICATION_PASSWORD_REQUIRED:
            self.fields.pop("password")

    def save(self):
        """
		COnfirm the email address matching the confirmation key
		"""
        self._confirmation.confirm()
        self._confirmation.delete()

    def validate(self, data):
        """
		Validate the provided data

		Returns:
			serializers.ValidationError:
				If the provided password is invalid.
		"""
        user = self._confirmation.email.user

        if (
            app_settings.EMAIL_VERIFICATION_PASSWORD_REQUIRED
            and not user.check_password(data["password"])
        ):
            raise serializers.ValidationError(__("The provided password is invalid."))

        # Add email to returned data
        data["email"] = self._confirmation.email.email

        return data

    def validate_key(self, key):
        """
		Validate the provided confirmation key.

		Returns:
			str:
				The validated confirmation key.

		Raises:
			serializers.ValidationError:
				If there is no email confirmation with the given key or
				the confirmation has expired.
		"""
        try:
            confirmation = models.EmailConfirmation.objects.select_related(
                "email__user"
            ).get(key=key)
        except models.EmailConfirmation.DoesNotExist:
            raise serializers.ValidationError(
                __("The provided verification key is invalide.")
            )

        if confirmation.is_expired:
            raise serializers.ValidationError(__("That verification code has expired."))

        # Cache
        self._confirmation = confirmation

        return key


class ResendVerificationSerializer(serializers.Serializer):
    """
	Serializer for resending a verification email.
	"""

    email = serializers.EmailField()

    def save(self):
        """
		Resend a verification email to the provided address.

		If the provided email is alreadt verified no action is taken.
		"""
        try:
            email = models.EmailAddress.objects.get(
                email=self.validated_data["email"], is_verified=False
            )

            logger.debug(
                "Resending verification email to %s", self.validated_data["email"]
            )

            email.send_confirmation()
        except models.EmailAddress.DoesNotExist:
            logger.debug(
                "Not resending verification email to %s because the address"
                "doesn't exist in the database.",
                self.validated_data["email"],
            )


class PasswordResetRequestSerializer(serializers.Serializer):
    """
	Serializer for requesting a password reset.
	"""

    email = serializers.EmailField(
        help_text=__("The email address to send the password reset to.")
    )

    def save(self):
        """
		Send out a password reset if the provided data is valid

		fuck I'm being too formal its depressing. covid fuck you.

		Returns:
			The password reset token if it was returned and ``None``
			otherwise.
		"""
        try:
            email = models.EmailAddress.objects.get(
                email=self.validated_data["email"], is_verified=True
            )
        except models.EmailAddress.DoesNotExist:
            return None

        token = models.PasswordResetToken.objects.create(email=email)
        token.send()

        return token


class PasswordResetSerializer(serializers.Serializer):
    """
	Serializer for reset a user's password.
	"""

    key = serializers.UUIDField(
        help_text=__("The key recieved by the user in the password reset " " email."),
        write_only=True,
    )
    password = serializers.CharField(
        help_text=__("The account's new password."),
        style={"input_type": "password"},
        write_only=True,
    )

    def save(self):
        """
		Reset the user's password if th eprovided information is valid.
		"""
        token = models.PasswordResetToken.objects.get(key=self.validated_data["key"])

        token.email.user.set_password(self.validated_data["password"])
        token.email.user.save()

        logger.info("Reset password for %s", token.email.user)

        token.delete()

    def validate_key(self, key):
        """
		Validate the provided reset key.


		Returns:
			The validated key.

		Raises:
			serializers.ValidationError:
				If the provided key does not exist.
		"""
        if not models.PasswordResetToken.valid_tokens.filter(key=key).exists():
            raise serializers.ValidationError(
                __("The provided reset token  does not exist, or is expired.")
            )

        return key

    def validate_password(self, password):
        """
		Validate the provided password by running it through Django's
		password validation system.

		Returns:
			The validated password.

		Raises:
			ValidationError:
				If the provided password does not pass the configured
				password validators.
		"""
        password_validation.validate_password(password)

        return password


class AccountSerializer(serializers.ModelSerializer):
    class Meta:
        model = get_user_model()
        fields = (
            "id",
            "last_login",
            "is_superuser",
            "username",
            "email",
            "phone_number",
            "is_active",
        )


# Social Logins serializer
class SocialSerializer(UserKnoxSerializer):
    def get_token(self, obj):
        instance, token = models.AuthToken.objects.create(obj)
        instance.save()
        return token
